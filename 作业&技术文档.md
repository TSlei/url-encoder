# 技术方案方案文档

## 一、作业需求

实现两个域名服务接口：

- 短域名存储接口：接受长域名信息，返回短域名信息

- 短域名读取接口：接受短域名信息，返回长域名信息

要求：

- 短域名长度最大为8个字符

- 采用SpringBoot，集成Swagger API文档

- JUnit编写单元测试，提交测试报告截图

- 映射数据存储在JVM内存即可，防止内存溢出

作业内容：

- 源代码干净整洁，忽略不需要文件
- 单测覆盖率达到85%+
- 完整的设计思路、架构设计图以及所做的假设



## 二、解决方案

- 采用三方guava包将长url进行hash运算，运算后的值转换成62进制字符串，最终长度不大于8（guava工具包api为beta版本，没去纠结），这里长度为6个字符。

- 采用新一代高性能缓存框架CaffeineCache保存映射关系，提升缓存命中率，高性能淘汰算法，防止内存溢出。目前使用的过期策略是基于时间过滤，也可以基于大小和引用过滤，此处没有实际场景，所以默认采用时间过滤，10秒过期，如果10秒内数据过大，可以基于大小过滤或引用过滤。
- 如果第一步出现冲突可以使用一个放号器，从0开始自增，然后转换成62进制，追加到后面。（概率极小，因此代码中未体现）

​	最开始想的是采用ConcurrentHashMap作为本地内存，但是考虑到缓存过期策略使用LRU还是LFU、定时器线程池定时过期、hash算法的效率不能保证，因此重复造轮子不仅复杂，而且得不偿失，于是采用第三方高性能框架CaffeineCache，解决了我诸多问题。

### CaffeineCache性能对比

<img src="/Users/chenze/Library/Application Support/typora-user-images/image-20220427145408104.png" alt="image-20220427145408104" style="zoom:67%;" />

<img src="/Users/chenze/Library/Application Support/typora-user-images/image-20220427145445691.png" alt="image-20220427145445691" style="zoom:67%;" />

<img src="/Users/chenze/Library/Application Support/typora-user-images/image-20220427145532353.png" alt="image-20220427145532353" style="zoom:67%;" />

<img src="/Users/chenze/Library/Application Support/typora-user-images/image-20220427145336195.png" alt="image-20220427145336195" style="zoom:67%;" />

### CaffeineCache特点

- 结合LRU和LFU算法生成新的W-TinyLFU算法，提升缓存命中率，减少内存占用，相比GuavaCache更加高性能
- Caffeine支持异步加载方式，直接返回CompletableFutures，相对于GuavaCache的同步方式，它不用阻塞等待数据的载入



## 三、系统介绍

### 链路时序图

接受长域名信息，返回短域名信息

<img src="/Users/chenze/Library/Application Support/typora-user-images/image-20220427170303070.png" alt="image-20220427170303070" style="zoom:67%;" />

接受短域名信息，返回长域名信息

<img src="/Users/chenze/Library/Application Support/typora-user-images/image-20220427170901649.png" alt="image-20220427170901649" style="zoom:67%;" />

### 代码结构

- url-encoder-starter：提供对外http接口服务

- url-encoder-service：处理http接口业务逻辑

- url-encoder-common：提供通用配置、工具包、异常处理



## 四、架构设计

复杂高可用的架构设计应结合实际复杂的业务场景设计，这里纯属YY的一个简单版本。

<img src="/Users/chenze/Library/Application Support/typora-user-images/image-20220427163656977.png" alt="image-20220427163656977" style="zoom:67%;" />

## 五、其他场景

- 可以添加用户登录接口鉴权防止恶意请求

- 由于外部原因导致应用关闭、或者机器关闭会导致缓存丢失、因此需要对缓存数据进行持久化

- 持久化后需要先查缓存再查数据库，需要对系统进行限流、鉴权，保护DB
- 使用缓存后可能出现各种异常场景、比如热点数据缓存击穿、缓存雪崩，可以修改过期策略，热点数据不过期、基于引用过期等

- 本系统没有什么复杂业务，所以没有打印日志，如果业务复杂需要打印日志，接入日志平台方便快速定位

- 在分布式场景下不易使用本地缓存，需要采用redis分布式缓存



## 六、作业截图

### 单测覆盖率和测试结果截图

<img src="/Users/chenze/Library/Application Support/typora-user-images/image-20220427171808301.png" alt="image-20220427171808301" style="zoom:67%;" />

<img src="/Users/chenze/Library/Application Support/typora-user-images/image-20220427171849701.png" alt="image-20220427171849701" style="zoom:67%;" />

### swagger页面截图

<img src="/Users/chenze/Library/Application Support/typora-user-images/image-20220427171951741.png" alt="image-20220427171951741" style="zoom:67%;" />

## 七、压测方案

1、首先粗略估算一般完成url的长度大小

2、根据系统配置、内存大小，JVM堆内存大小估算出大概可以保存的key-value对总数total

3、使用其他机器作为施压机，多线程分别请求http读、写接口，直到达到total值为止，统计最高qps值，观察系统cpu、内存等压力

4、根据压测结果得到单机所能支撑的最高写qps和读qps数从而得到系统性能

PS：由于本机装了过多软件服务又是公司机器，条件不允许，为了压测作业随便写个运行脚本跑一下程序，服务机器和试压机器用同一台机器，必然结果完全不准，是没有意义的压测，因此没有进行实践压测，只写了大概方案。